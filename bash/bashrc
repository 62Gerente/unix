# ------------------- ALIAS --------------------

# CLEAR

alias c='clear'

# GIT COMMANDS

alias gpom='git push origin master'
alias gcm='git commit -m'
alias gc='git commit'
alias gcam='git commit -am'
alias gp='git pull'
alias gaa='git add .'
alias ga='git add'
alias grm='git rm'
alias gs='git status'

# CD

alias aulas='cd ~/Aulas/'
alias pl='cd ~/Aulas/PL/'
alias meio='cd ~/Aulas/MEIO/'
alias li4='cd ~/Aulas/LI4/'
alias cg='cd ~/Aulas/CG/'
alias srcr='cd ~/Aulas/SRCR/'
alias cc='cd ~/Aulas/CC/'

alias downl='cd ~/Downloads/'
alias drop='cd ~/Dropbox/'

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'

# LS

alias la='ls -a'
alias ll='ls -lh'
alias lla='ls -lah'


#-------------------- EXTRACT --------------------

extract () { # extract files. Ignore files with improper extensions.
    local x
    ee() { # echo and execute
            echo "$@"
            $1 "$2"
        }
    for x in "$@"; do
        [[ -f $x  ]] || continue
        case "$x" in
            *.tar.bz2 | *.tbz2 )    ee "tar xvjf" "$x"   ;;
            *.tar.gz | *.tgz )      ee "tar xvzf" "$x"   ;;
            *.bz2 )                 ee "bunzip2" "$x"    ;;
            *.rar )                 ee "unrar x" "$x"    ;;
            *.gz )                  ee "gunzip" "$x"     ;;
            *.tar )                 ee "tar xvf" "$x"    ;;
            *.zip )                 ee "unzip" "$x"      ;;
            *.Z )                   ee "uncompress" "$x" ;;
            *.7z )                  ee "7z x" "$x"       ;;
        esac
    done
}

#-------------------- MAN PAGES --------------------

export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'

#-------------------- MKCD --------------------

mkcd() {
    if [ $# != 1  ]; then
        echo "Usage: mkcd <dir>"
    else
        mkdir -p $1 && cd $1
    fi
}

#-------------------- CD LAST CHANGED --------------------

cl()
{
    last_dir="$(ls -Frt | grep '/$' | tail -n1)"
    if [ -d "$last_dir"  ]; then
        cd "$last_dir"
    fi
}

#-------------------- GIT PROMPT --------------------

git-prompt () {
    # either a git branch exists or no repo at all, so go home
    git branch &>/dev/null || return 1;
    # set the HEAD reference
    GIT_PROMPT_HEAD="$(git symbolic-ref HEAD 2>/dev/null)";
    # extract the name of the branch from the reference
    GIT_PROMPT_BRANCH="${GIT_PROMPT_HEAD##*/}";

    if [ `git diff --name-only --diff-filter=U` ];
    then
        # that condition should return the list of conflicts
        GIT_PROMPT_STATUS="\[\e31;1m\]";
    else
        GIT_PROMPT_DIR_CLEAN=`git status | grep -F 'working directory clean'`;
        if [ "$GIT_PROMPT_DIR_CLEAN" ];
        then
            GIT_PROMPT_STATUS="\[\e[32m\]";
        else
            GIT_PROMPT_STATUS="\[\e[33m\]";
        fi;
    fi;
    echo "${GIT_PROMPT_STATUS}${GIT_PROMPT_BRANCH:-unknown}\[\e[0m\]";

    # cleanup
    unset GIT_PROMPT_HEAD;
    unset GIT_PROMPT_BRANCH;
    unset GIT_PROMPT_STATUS;
    unset GIT_PROMPT_DIR_CLEAN;
}

function git_prompt() {
    local git_status="`git status -unormal 2>&1`"
    if ! [[ "$git_status" =~ Not\ a\ git\ repo  ]]; then
                if [[ "$git_status" =~ nothing\ to\ commit  ]]; then
                    local ansi=32
                elif [[ "$git_status" =~ nothing\ added\ to\ commit\ but\ untracked\ files\present  ]]; then
                    local ansi=34
    else
    local ansi=33
    fi  
#    echo -n '\[\e[0;33;'"$ansi"'m\]'"$(__git_ps1)"'\[\e[0m\]'
    echo -n '\[\e[0;33;'"$ansi"'m\]' "$(git-prompt)" '\[\e[0m\]'
    fi
}
function _prompt_command() {
      PS1="[\[\033[32m\]\w\[\033[0m\]]\[\033[0m\]\n\[\033[1;36m\]\u@\[\033[0;37m\]\h] `git_prompt` \[\033[1;33m\]: \[\033[0m\]"
  }
PROMPT_COMMAND=_prompt_command

